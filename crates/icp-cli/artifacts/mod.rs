//! Artifact bundling system for embedding external files into the binary.
//!
//! This module provides build-time functionality to download artifacts (like WASM files),
//! verify their integrity, and embed them into the compiled binary using `include_bytes!`.
//!
//! # How It Works
//!
//! 1. **`source.json`** defines artifacts with their URLs and SHA256 checksums
//! 2. During build, artifacts are cached in `target/icp-cli-artifact-cache/`
//! 3. If a cached artifact exists with matching SHA256, it's reused (no download)
//! 4. If missing or hash mismatch, the artifact is downloaded and verified
//! 5. Generated code uses `include_bytes!` with absolute paths to cached artifacts
//!
//! # Adding a New Artifact
//!
//! Add an entry to `artifacts/source.json`:
//! ```json
//! {
//!     "my_artifact": {
//!         "url": "https://example.com/artifact.wasm",
//!         "sha256": "abc123..."
//!     }
//! }
//! ```
//!
//! Access it in your code:
//! ```ignore
//! include!(concat!(env!("OUT_DIR"), "/artifacts.rs"));
//!
//! let bytes = my_artifact(); // Returns &'static [u8]
//! ```
//!
//! Note: Hyphens in artifact names become underscores in function names.

// It's okay to use std::path::{Path, PathBuf} in build scripts.
#![allow(clippy::disallowed_types)]

use std::collections::HashMap;
use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};

#[derive(Debug, Serialize, Deserialize)]
struct Source {
    url: String,
    sha256: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct SourceFile {
    #[serde(flatten)]
    artifacts: HashMap<String, Source>,
}

/// Computes the SHA256 hash of a file
fn compute_file_sha256(path: &Path) -> Result<String, std::io::Error> {
    let bytes = fs::read(path)?;
    let hash = Sha256::digest(&bytes);
    Ok(hex::encode(hash))
}

/// Gets an artifact from cache or downloads it if not cached or SHA256 doesn't match
fn get_or_download_artifact(name: &str, url: &str, expected_sha256: &str, cache_path: &Path) {
    // Check if cached file exists and has matching SHA256
    if cache_path.exists() {
        match compute_file_sha256(cache_path) {
            Ok(cached_hash) if cached_hash == expected_sha256 => {
                eprintln!("Using cached artifact '{}' (SHA256: {})", name, cached_hash);
                return;
            }
            Ok(cached_hash) => {
                eprintln!(
                    "Cached artifact '{}' has mismatched SHA256 (expected: {}, got: {}), re-downloading",
                    name, expected_sha256, cached_hash
                );
            }
            Err(e) => {
                eprintln!(
                    "Failed to read cached artifact '{}': {}, re-downloading",
                    name, e
                );
            }
        }
    }

    // Download artifact
    eprintln!("Downloading artifact '{}' from: {}", name, url);

    let response = reqwest::blocking::get(url)
        .unwrap_or_else(|e| panic!("failed to download artifact from {}: {}", url, e));
    if !response.status().is_success() {
        panic!("failed to download artifact: HTTP {}", response.status());
    }

    let bytes = response
        .bytes()
        .unwrap_or_else(|e| panic!("failed to read response bytes: {}", e))
        .to_vec();

    // Verify SHA256
    let hash = Sha256::digest(&bytes);
    let hash_hex = hex::encode(hash);
    if hash_hex != expected_sha256 {
        panic!(
            "SHA256 mismatch for {}: expected {}, got {}",
            url, expected_sha256, hash_hex
        );
    }

    // Save to cache
    if let Some(parent) = cache_path.parent() {
        fs::create_dir_all(parent).unwrap_or_else(|e| {
            panic!(
                "failed to create cache directory {}: {}",
                parent.display(),
                e
            )
        });
    }

    fs::write(cache_path, &bytes).unwrap_or_else(|e| {
        panic!(
            "failed to write to cache file {}: {}",
            cache_path.display(),
            e
        )
    });

    eprintln!(
        "Successfully downloaded and cached artifact '{}' (SHA256: {})",
        name, hash_hex
    );
}

/// Generates Rust code that embeds the artifacts using include_bytes! from cache
fn generate_artifacts_code(artifact_names: &[String], cache_dir: &Path) -> String {
    let mut code = String::from("// This file is generated by build.rs. Do not edit manually.\n\n");

    for name in artifact_names {
        // Convert name to valid Rust function name (replace hyphens with underscores)
        let fn_name = name.replace('-', "_");

        // Reference the cached artifact file
        let artifact_filename = format!("{}.bin", name);
        let artifact_path = cache_dir.join(&artifact_filename);
        let artifact_path_str = artifact_path.to_str().unwrap_or_else(|| {
            panic!(
                "cache path contains invalid UTF-8: {}",
                artifact_path.display()
            )
        });

        code.push_str(&format!(
            "/// Returns the embedded `{}` artifact as a byte slice\n",
            name
        ));
        code.push_str(&format!("pub fn {}() -> &'static [u8] {{\n", fn_name));
        code.push_str(&format!("    include_bytes!(\"{}\")\n", artifact_path_str));
        code.push_str("}\n\n");
    }

    code
}

/// Main function to process artifacts: download them and generate Rust code
fn process_artifacts(artifacts_source_path: &Path, output_dir: &Path, cache_dir: &Path) {
    // Read the artifacts source JSON file
    let json_content = fs::read_to_string(artifacts_source_path).unwrap_or_else(|e| {
        panic!(
            "failed to read artifacts source file {}: {}",
            artifacts_source_path.display(),
            e
        )
    });
    let artifacts_source: SourceFile = serde_json::from_str(&json_content)
        .unwrap_or_else(|e| panic!("failed to parse artifacts source JSON: {}", e));

    eprintln!("Processing {} artifacts", artifacts_source.artifacts.len());

    eprintln!("Using artifact cache directory: {}", cache_dir.display());

    // Get or download all artifacts to cache
    let mut artifact_names = Vec::new();
    for (name, source) in &artifacts_source.artifacts {
        eprintln!("Processing artifact: {}", name);
        let cache_file = cache_dir.join(format!("{}.bin", name));
        get_or_download_artifact(name, &source.url, &source.sha256, &cache_file);
        artifact_names.push(name.clone());
    }

    // Generate Rust code that references cached artifacts
    let generated_code = generate_artifacts_code(&artifact_names, cache_dir);

    // Write to OUT_DIR/artifacts.rs
    let output_path = output_dir.join("artifacts.rs");
    let mut file = fs::File::create(&output_path).unwrap_or_else(|e| {
        panic!(
            "failed to create output file {}: {}",
            output_path.display(),
            e
        )
    });
    file.write_all(generated_code.as_bytes())
        .unwrap_or_else(|e| {
            panic!(
                "failed to write to output file {}: {}",
                output_path.display(),
                e
            )
        });

    eprintln!("Generated artifacts code at: {}", output_path.display());
}

/// High-level function to bundle artifacts during build.
///
/// This reads environment variables to determine paths and calls `process_artifacts`.
pub fn bundle_artifacts() {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set");
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");

    let artifacts_source_path = PathBuf::from(&manifest_dir).join("artifacts/source.json");
    let output_dir = PathBuf::from(out_dir);

    // Cache directory is at workspace root target/icp-cli-artifact-cache
    // manifest_dir is at crates/icp-cli, so go up 2 levels to workspace root
    let cache_dir = PathBuf::from(&manifest_dir)
        .parent()
        .and_then(|p| p.parent())
        .expect("failed to find workspace root")
        .join("target/icp-cli-artifact-cache");

    process_artifacts(&artifacts_source_path, &output_dir, &cache_dir);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_artifacts_code() {
        let temp_dir = camino_tempfile::tempdir().unwrap();

        // Create a test artifact file in the cache directory
        let artifact_name = "test_artifact".to_string();
        let artifact_path = temp_dir.path().join("test_artifact.bin");
        fs::write(&artifact_path, vec![0x00, 0x01, 0x02, 0xFF]).unwrap();

        let artifact_names = vec![artifact_name];
        let code = generate_artifacts_code(&artifact_names, temp_dir.path());

        assert!(code.contains("pub fn test_artifact() -> &'static [u8]"));
        assert!(code.contains("include_bytes!"));
        assert!(code.contains("test_artifact.bin"));
    }

    #[test]
    fn test_name_with_hyphens() {
        let temp_dir = camino_tempfile::tempdir().unwrap();

        // Create a test artifact file with hyphens
        let artifact_name = "my-artifact".to_string();
        let artifact_path = temp_dir.path().join("my-artifact.bin");
        fs::write(&artifact_path, vec![0xAB]).unwrap();

        let artifact_names = vec![artifact_name];
        let code = generate_artifacts_code(&artifact_names, temp_dir.path());

        // Function name should have underscores instead of hyphens
        assert!(code.contains("pub fn my_artifact() -> &'static [u8]"));
        // But file name should keep the original name
        assert!(code.contains("my-artifact.bin"));
    }
}
