//! Artifact bundling system for embedding external files into the binary.
//!
//! This module provides build-time functionality to download artifacts (like WASM files),
//! verify their integrity, and embed them into the compiled binary using `include_bytes!`.
//!
//! # How It Works
//!
//! 1. **`source.json`** defines artifacts with their URLs and SHA256 checksums
//! 2. During build, each artifact is downloaded and verified
//! 3. Artifacts are saved as `.bin` files in `$OUT_DIR`
//! 4. Generated code uses `include_bytes!` to embed them in the binary
//!
//! # Adding a New Artifact
//!
//! Add an entry to `artifacts/source.json`:
//! ```json
//! {
//!     "my_artifact": {
//!         "url": "https://example.com/artifact.wasm",
//!         "sha256": "abc123..."
//!     }
//! }
//! ```
//!
//! Access it in your code:
//! ```ignore
//! include!(concat!(env!("OUT_DIR"), "/artifacts.rs"));
//!
//! let bytes = my_artifact(); // Returns &'static [u8]
//! ```
//!
//! Note: Hyphens in artifact names become underscores in function names.

use std::collections::HashMap;
use std::fs;
use std::io::Write;
use std::path::Path;

use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};

#[derive(Debug, Serialize, Deserialize)]
struct Source {
    url: String,
    sha256: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct SourceFile {
    #[serde(flatten)]
    artifacts: HashMap<String, Source>,
}

/// Downloads an artifact from a URL and verifies its SHA256 checksum
fn download_artifact(
    url: &str,
    expected_sha256: &str,
) -> Vec<u8> {
    println!("cargo:warning=Downloading artifact from: {}", url);

    let response = reqwest::blocking::get(url)
        .unwrap_or_else(|e| panic!("Failed to download artifact from {}: {}", url, e));
    if !response.status().is_success() {
        panic!("Failed to download artifact: HTTP {}", response.status());
    }

    let bytes = response.bytes()
        .unwrap_or_else(|e| panic!("Failed to read response bytes: {}", e))
        .to_vec();

    // Verify SHA256
    let hash = Sha256::digest(&bytes);
    let hash_hex = hex::encode(hash);
    if hash_hex != expected_sha256 {
        panic!(
            "SHA256 mismatch for {}: expected {}, got {}",
            url, expected_sha256, hash_hex
        );
    }

    println!(
        "cargo:warning=Successfully downloaded and verified artifact (SHA256: {})",
        hash_hex
    );
    bytes
}

/// Generates Rust code that embeds the artifacts using include_bytes!
fn generate_artifacts_code(
    artifacts: &HashMap<String, Vec<u8>>,
    output_dir: &Path,
) -> String {
    let mut code = String::from("// This file is generated by build.rs. Do not edit manually.\n\n");

    for (name, bytes) in artifacts {
        // Convert name to valid Rust function name (replace hyphens with underscores)
        let fn_name = name.replace('-', "_");

        // Write the artifact bytes to a separate file
        let artifact_filename = format!("{}.bin", name);
        let artifact_path = output_dir.join(&artifact_filename);
        fs::write(&artifact_path, bytes)
            .unwrap_or_else(|e| panic!("Failed to write artifact file {}: {}", artifact_path.display(), e));

        code.push_str(&format!(
            "/// Returns the embedded `{}` artifact as a byte slice\n",
            name
        ));
        code.push_str(&format!("pub fn {}() -> &'static [u8] {{\n", fn_name));
        code.push_str(&format!("    include_bytes!(\"{}\")\n", artifact_filename));
        code.push_str("}\n\n");
    }

    code
}

/// Main function to process artifacts: download them and generate Rust code
pub fn process_artifacts(
    artifacts_source_path: &Path,
    output_dir: &Path,
) {
    println!("cargo:rerun-if-changed={}", artifacts_source_path.display());

    // Read the artifacts source JSON file
    let json_content = fs::read_to_string(artifacts_source_path)
        .unwrap_or_else(|e| panic!("Failed to read artifacts source file {}: {}", artifacts_source_path.display(), e));
    let artifacts_source: SourceFile = serde_json::from_str(&json_content)
        .unwrap_or_else(|e| panic!("Failed to parse artifacts source JSON: {}", e));

    println!(
        "cargo:warning=Processing {} artifacts",
        artifacts_source.artifacts.len()
    );

    // Download all artifacts
    let mut downloaded_artifacts = HashMap::new();
    for (name, source) in &artifacts_source.artifacts {
        println!("cargo:warning=Processing artifact: {}", name);
        let bytes = download_artifact(&source.url, &source.sha256);
        downloaded_artifacts.insert(name.clone(), bytes);
    }

    // Generate Rust code
    let generated_code = generate_artifacts_code(&downloaded_artifacts, output_dir);

    // Write to OUT_DIR/artifacts.rs
    let output_path = output_dir.join("artifacts.rs");
    let mut file = fs::File::create(&output_path)
        .unwrap_or_else(|e| panic!("Failed to create output file {}: {}", output_path.display(), e));
    file.write_all(generated_code.as_bytes())
        .unwrap_or_else(|e| panic!("Failed to write to output file {}: {}", output_path.display(), e));

    println!(
        "cargo:warning=Generated artifacts code at: {}",
        output_path.display()
    );
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_artifacts_code() {
        use std::io::Read;

        let temp_dir = camino_tempfile::tempdir().unwrap();
        let mut artifacts = HashMap::new();
        artifacts.insert("test_artifact".to_string(), vec![0x00, 0x01, 0x02, 0xFF]);

        let code = generate_artifacts_code(&artifacts, temp_dir.path());

        assert!(code.contains("pub fn test_artifact() -> &'static [u8]"));
        assert!(code.contains("include_bytes!(\"test_artifact.bin\")"));

        // Verify the binary file was created
        let bin_path = temp_dir.path().join("test_artifact.bin");
        assert!(bin_path.exists());

        let mut file = fs::File::open(bin_path).unwrap();
        let mut contents = Vec::new();
        file.read_to_end(&mut contents).unwrap();
        assert_eq!(contents, vec![0x00, 0x01, 0x02, 0xFF]);
    }

    #[test]
    fn test_name_with_hyphens() {
        let temp_dir = camino_tempfile::tempdir().unwrap();
        let mut artifacts = HashMap::new();
        artifacts.insert("my-artifact".to_string(), vec![0xAB]);

        let code = generate_artifacts_code(&artifacts, temp_dir.path());

        // Function name should have underscores instead of hyphens
        assert!(code.contains("pub fn my_artifact() -> &'static [u8]"));
        // But file name should keep the original name
        assert!(code.contains("include_bytes!(\"my-artifact.bin\")"));
    }
}
